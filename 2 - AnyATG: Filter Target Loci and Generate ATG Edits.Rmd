---
title: "Filter Target Loci and Generate ATG Edits"
author: "Katya Williams"
date: "`r Sys.Date()`"
output: html_document
---

# 1. Setup

## 1.1 Import necessary libraries

```{r setup}
# Load any necessary libraries
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(seqinr)
library(friendlyeval)
```

## 1.2 Read in top target site candidate dataset

*This script creates 1bp indels or substitutions anywhere after the PAM sequence, so it should only be used with `MMR-responsive_any_target_candidates.csv`*

```{r read-lDS004}
# read in lDS004 data (from Ann Cirincione)
top <- read_csv('MMR-responsive_any_target_candidates.csv')
```

## 1.3 Read in any auxiliary datasets

```{r read-aux, eval=F}

````

# 2. Filter candidate target sites

## 2.1 Generate truncated target sequences

Create truncated target sequences along with a non-editing RT (modified from Ann's RTs)

```{r oligos}
# initialize empty vectors
RT_revert <- vector(length=nrow(top))
PAM <- vector(length=nrow(top))
Target <- vector(length=nrow(top))
coding_seq <- vector(length=nrow(top))

# change 5th nt in RT_revcomp to value of Edited_nt
for(i in 1:nrow(top)) {
    # get reverse complement of RT
    RT_revcomp <- toupper(paste(rev(comp(unlist(strsplit(top$RT_template[i], '')))), collapse=''))
    # extract PAM sequence from reverse complement RT
    ## PAM encoded as reverse complement at end of RT sequence (bases 4-6)
    ## need to change 5th base in reverse complement back to original
    split <- unlist(strsplit(RT_revcomp, ""))
    split[5] <- top$Reference_nt[i]
    RT_revert_rc <- paste(split, collapse='')
    # generate unedited RT template
    RT_revert[i] <- toupper(paste(rev(comp(unlist(strsplit(RT_revert_rc, '')))), collapse=''))
    # generate PAM alone
    PAM[i] <- toupper(substr(RT_revert_rc, 4, 6))
    
    # find the index of the nt immediately after the end of the PAM sequence in the wide target
    after_start <- unlist(gregexpr(top$Protospacer[i], top$Wide_target_sequence[i], fixed=TRUE)) + 23
    # find the length of the end of the RT template in the wide target
    after_endlen <- top$RT_length[i] - 7
    # substring the wide target nt between the PAM and end of the RT -- these are necessary for full RT binding
    after_PAM <- substr(top$Wide_target_sequence[i], after_start, after_start + after_endlen)
    # store the start of the coding sequence (concatenate edited PAM and after_PAM)
    coding_seq[i] <- paste(toupper(c('ATG', after_PAM)), collapse='')
    # generate minimal target sequence (protospacer + PAM)
    Target[i] <- paste(toupper(c(top$Protospacer[i], PAM[i], after_PAM)), collapse='')
}

# add columns to dataset
top <- top %>% mutate(RT_revert = RT_revert,
                      PAM = PAM,
                      Target = Target,
                      Start_of_Coding_Seq = coding_seq)
```

## 2.2 Truncated target start codon filtering

Remove targets already containing start codons: otherwise, reporter will be active regardless of editing

**This code identifies start codons in both the forward direction, where the PAM is on the coding (sense) strand, and in the reverse direction, where the PAM is on the non-coding (nonsense) strand.** Reverse-oriented target sequences allow strand invasion away from the reporter sequence and introduce fewer indels into the coding sequence.

```{r valid-targets}
## forward-oriented edits: look for ATG in target sequence
## reverse-oriented edits: look for CAT in target sequence (reverse complement of ATG)

# check for start codons in the target seq (protospacer + PAM)
top <- top %>% mutate(Target_hasATG_f = grepl('ATG', top$Target, fixed = TRUE),
                      Target_hasATG_r = grepl('CAT', top$Target, fixed = TRUE))

# generate table of only start codon-less targets
## peg_library_start_f: start codon-less targets in the forward direction
peg_library_start_f <- top %>% 
    filter(Target_hasATG_f == FALSE)
## peg_library_start_r: start codon-less targets in the reverse direction
peg_library_start_r <- top %>% 
    filter(Target_hasATG_r == FALSE)

# which loci have a working target in both the forward and reverse directions?
loci_both <- intersect(peg_library_start_f$Target_Locus, peg_library_start_r$Target_Locus)
length(loci_both)
# which loci are missing from the forward-facing targets?
loci_f <- setdiff(top$Target_Locus, peg_library_start_f$Target_Locus)
length(loci_f)
# which locu are missing from the reverse-facing targets?
loci_r <- setdiff(top$Target_Locus, peg_library_start_r$Target_Locus)
length(loci_r)
# which loci are missing from both datasets?
loci_miss <- intersect(loci_f, loci_r)
loci_miss
```

## 2.3 Finding Editable Sequences

1) Search the target sequences for any sequence that can be edited to ATG by a 1bp insertion, substitution, or deletion
2) 

ATG reverse complement is CAT

G/C insertion/substitution: find AT forward, AT reverse (+2/-1nt after index)
A/T insertion/substitution: find TG forward, CA reverse (-1/+2nt after index)
T/A insertion: find AG forward, CT reverse (+1/+1nt after index)

T/A substitution: find ANG forward, CNT reverse (+1/+1nt after index)

ANTG/CANT deletion: find ANTG forward, CANT reverse (+1/+2nt after index)
ATNG/CNAT deletion: find ATNG forward, CNAT reverse (+2/+1nt after index)

### 2.3.1 Search the target sequences for potential ATG sites

```{r forloop-iteratives}
# store the search terms to find each edit 
searchterm_f <- c('AT','TG','AG','A.G','A.TG','AT.G')
searchterm_r <- c('AT','CA','CT','C.T','CA.T','C.AT')

# store the adjustment value for the start of the edit index

# store the column names to be added to the datasets
inTarget_f_name <- c('AT_inTarget_f', 'TG_inTarget_f', 'AG_inTarget_f',
                'ANG_inTarget_f', 'ANTG_inTarget_f', 'ATNG_inTarget_f')
inTarget_r_name <- c('AT_inTarget_r', 'CA_inTarget_r', 'CT_inTarget_r',
                'CNT_inTarget_r', 'CANT_inTarget_r', 'CNAT_inTarget_r')
inWide_f_name <- c('AT_inWide_f', 'TG_inWide_f', 'AG_inWide_f',
              'ANG_inWide_f', 'ANTG_inWide_f', 'ATNG_iinWide_f')
inWide_r_name <- c('AT_inWide_r', 'CA_inWide_r', 'CT_inWide_r',
              'CNT_inWide_r', 'CANT_inWide_r', 'CNAT_inWide_r')
```

```{r edit-site-finding}
# find the edit sites for each search term manually entered into the vectors
for (i in 1:length(searchterm_f)) {
    # for each target locus, find all indices of instances of forward + reverse search term and store as a list
    inTarget_flist <- gregexpr(searchterm_f[i], peg_library_start_f$Target, fixed=TRUE)
    inTarget_rlist <- gregexpr(searchterm_r[i], peg_library_start_r$Target, fixed=TRUE)
    inWide_flist <- gregexpr(searchterm_f[i], peg_library_start_f$Wide_target_sequence, fixed=TRUE)
    inWide_rlist <- gregexpr(searchterm_r[i], peg_library_start_r$Wide_target_sequence, fixed=TRUE)
    
    # create storage vectors to unpack lists
    inTarget_f <- vector(length=nrow(peg_library_start_f))
    inTarget_r <- vector(length=nrow(peg_library_start_r))
    inWide_f <- vector(length=nrow(peg_library_start_f))
    inWide_r <- vector(length=nrow(peg_library_start_r))
    
    # unpack lists into storage vectors
    for (j in 1:nrow(peg_library_start_f)) {
        inTarget_f[j] <- unlist(inTarget_flist[j])
        inWide_f[j] <- unlist(inWide_flist[j])
    }
    
    for (j in 1:nrow(peg_library_start_r)) {
        inTarget_r[j] <- toString(unlist(inTarget_rlist[j]))
        inWide_r[j] <- toString(unlist(inWide_rlist[j]))
    }
    
    
    
    # add information as new column to the datasets
    peg_library_start_f <- peg_library_start_f %>% mutate(!!inTarget_f_name[i] := inTarget_f,
                                                          !!inWide_f_name[i] := inWide_f)
    peg_library_start_r <- peg_library_start_r %>% mutate(!!inTarget_r_name[i] := inTarget_r,
                                                          !!inWide_r_name[i] := inWide_r)
}
```

### 2.2.2 Remove any edits where the coding sequence contains a stop codon after the PAM from the data

Otherwise, the reporter will be inactive regardless of editing: the reporter cannot be translated, even if a start codon is successfully introduced

```{r remove-stop}
codon_list <- vector(length=nrow(peg_library_start))

# split sequence into codons
for (i in 1:nrow(peg_library_start)) {
    # split the seq into a vector of individual characters
    seq <- unlist(strsplit(peg_library_start$Start_of_Coding_Seq[i], ''))
    codons <- splitseq(seq, frame=0, word=3)
    codon_list[i] <- toString(codons)
}

peg_library_start <- peg_library_start %>% mutate(Starting_Codons = codon_list)

# search for stop codons in Start_of_Coding_Seq
peg_library_start <- peg_library_start %>% mutate(Coding_hasUAA = grepl('TAA', peg_library_start$Starting_Codons, fixed = TRUE),
                                      Coding_hasUAG = grepl('TAG', peg_library_start$Starting_Codons, fixed = TRUE),
                                      Coding_hasUGA = grepl('TGA', peg_library_start$Starting_Codons, fixed = TRUE))

# storage vector for for loop
anystops <- c()

# for each row...
for (i in 1:nrow(peg_library_start)) {
    # are any of the stop codons present?
    stops <- any(c(peg_library_start$Coding_hasUAA[i] == TRUE, 
                   peg_library_start$Coding_hasUAG[i] == TRUE,
                   peg_library_start$Coding_hasUGA[i] == TRUE))
    anystops <- c(anystops, stops)
}

peg_library_start <- peg_library_start %>% mutate(Coding_hasStop = anystops)

# remove any data where Coding_hasStop == TRUE
peg_library_stops <- peg_library_start %>% filter(Coding_hasStop == FALSE)
```




# 4. Export top *n* edits and associated information

## 4.1 Print number of edits

```{r n-edits}
# print # of edits in data
nrow(peg_library_stops)
```

## 4.2 Save a target site edit efficiency summary figure

Graph an overlay of the selected target sites' PEmax vs MLH1 KO efficiency over the original data

```{r efficiency}
# add a column to Ann's original data if the gene was used in my design
diff <- diff %>% mutate(In_New_Library = Target_Locus %in% peg_library_stops$Target_Locus)

# graph the efficiency, with genes in the new library highlighted
ggplot(diff, aes(x=PEmax_Avg_Freq_EditOnly_d7,y=MLH1_Avg_Freq_EditOnly_d7,
                    color=In_New_Library)) +
    geom_point(shape=20, aes(alpha=0.3)) +
    scale_color_manual(values=c('#595959','red')) +
    labs(title='Editing Efficacy by Target Site',
         x='PEmax Average
Editing Frequency',
         y='MLH1 KO Average
Editing Frequency') +
    theme_classic()
ggsave('efficiency_distribution_top_target_site.png', plot = last_plot(), device = 'png', path = 'Summary Figures', scale = 1, width = 3.75, height = 2.5, units = "in", dpi = 300)
```

## 4.3 Export target loci data

```{r export}
# export files
write.csv(peg_library_stops, 'MMR-responsive_ATG_edit_candidates.csv', row.names=TRUE)
```